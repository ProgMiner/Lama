\import Arith.Int
\import Data.Array
\import Function
\import Expr
\import Function.Meta
\import Memory
\import Paths.Meta
\import Scope
\import Telescope
\import Logic
\import Logic.Meta
\import Paths
\import Relation.Equivalence
\import Utils

\func State => \Sigma Scope Memory

\data EvalBinop (b : Binop) (x y z : Int) \elim b
  | bPlus => ebPlus (z = x IntRing.+ y)
  | bMinus => ebMinus (z = x IntRing.+ IntRing.negative y)
  | bMul => ebMul (z = x IntRing.* y)
  | bEq => ebEqTrue (x = y) (z = 1)
  | bEq => ebEqFalse (x /= y) (z = 0)
  | bNe => ebNeTrue (x /= y) (z = 1)
  | bNe => ebNeFalse (x = y) (z = 0)
  | bLt => ebLtTrue (x IntRing.< y) (z = 1)
  | bLt => ebLtFalse (x IntRing.>= y) (z = 0)
  | bLe => ebLeTrue (x IntRing.<= y) (z = 1)
  | bLe => ebLeFalse (x IntRing.> y) (z = 0)
  | bGt => ebGtTrue (x IntRing.> y) (z = 1)
  | bGt => ebGtFalse (x IntRing.<= y) (z = 0)
  | bGe => ebGeTrue (x IntRing.>= y) (z = 1)
  | bGe => ebGeFalse (x IntRing.< y) (z = 0)
  \where {

    \use \level levelProp {b : Binop} {x y z : Int} (p q : EvalBinop b x y z) : p = q \elim b, p, q
      | bPlus, ebPlus p, ebPlus q => pmap ebPlus propPath
      | bMinus, ebMinus p, ebMinus q => pmap ebMinus propPath
      | bMul, ebMul p, ebMul q => pmap ebMul propPath
      | bEq, ebEqTrue p p1, ebEqTrue q q1 => pmap2 ebEqTrue propPath propPath
      | bEq, ebEqTrue p p1, ebEqFalse q q1 => \case q p
      | bEq, ebEqFalse p p1, ebEqTrue q q1 => \case p q
      | bEq, ebEqFalse p p1, ebEqFalse q q1 => pmap2 ebEqFalse propPath propPath
      | bNe, ebNeTrue p p1, ebNeTrue q q1 => pmap2 ebNeTrue propPath propPath
      | bNe, ebNeTrue p p1, ebNeFalse q q1 => \case p q
      | bNe, ebNeFalse p p1, ebNeTrue q q1 => \case q p
      | bNe, ebNeFalse p p1, ebNeFalse q q1 => pmap2 ebNeFalse propPath propPath
      | bLt, ebLtTrue p p1, ebLtTrue q q1 => pmap2 ebLtTrue propPath propPath
      | bLt, ebLtTrue p p1, ebLtFalse q q1 => contradiction
      | bLt, ebLtFalse p p1, ebLtTrue q q1 => contradiction
      | bLt, ebLtFalse p p1, ebLtFalse q q1 => pmap2 ebLtFalse propPath propPath
      | bLe, ebLeTrue p p1, ebLeTrue q q1 => pmap2 ebLeTrue propPath propPath
      | bLe, ebLeTrue p p1, ebLeFalse q q1 => contradiction
      | bLe, ebLeFalse p p1, ebLeTrue q q1 => contradiction
      | bLe, ebLeFalse p p1, ebLeFalse q q1 => pmap2 ebLeFalse propPath propPath
      | bGt, ebGtTrue p p1, ebGtTrue q q1 => pmap2 ebGtTrue propPath propPath
      | bGt, ebGtTrue p p1, ebGtFalse q q1 => contradiction
      | bGt, ebGtFalse p p1, ebGtTrue q q1 => contradiction
      | bGt, ebGtFalse p p1, ebGtFalse q q1 => pmap2 ebGtFalse propPath propPath
      | bGe, ebGeTrue p p1, ebGeTrue q q1 => pmap2 ebGeTrue propPath propPath
      | bGe, ebGeTrue p p1, ebGeFalse q q1 => contradiction
      | bGe, ebGeFalse p p1, ebGeTrue q q1 => contradiction
      | bGe, ebGeFalse p p1, ebGeFalse q q1 => pmap2 ebGeFalse propPath propPath
  }

\data Match (m : Memory) (x : Value) (p : Pattern) (sc : Scope.Scope') \elim x, p, sc
  | _, pWildcard, nil => mWildcard
  | x, pNamed v p, sc' => mNamed {sc : Scope.Scope'} (Match m x p sc) (sc' = sc ++ (v, x) :: nil)
  | vLoc l, pArray {n} ps, sc' => mArray {xs : Array Value n} {scs : Array Scope.Scope' n}
                                         (Telescope.Get m l (bvArray xs))
                                         (DArray {n} (\lam i => Match m (xs i) (ps i) (scs i)))
                                         (sc' = fold (\lam (sc : Scope.Scope') acc => acc ++ sc) (nil : Scope.Scope') scs)
  | vLoc l, pSexp lb {n} ps, sc' => mSexp {xs : Array Value n} {scs : Array Scope.Scope' n}
                                          (Telescope.Get m l (bvSexp lb xs))
                                          (DArray {n} (\lam i => Match m (xs i) (ps i) (scs i)))
                                          (sc' = fold (\lam (sc : Scope.Scope') acc => acc ++ sc) (nil : Scope.Scope') scs)
  | vInt x, pInt y, nil => mInt (x = y)
  | vLoc l, pString s, nil => mString (Telescope.Get m l (bvString s))
  | vLoc _, pBoxed, nil => mBoxed
  | vInt _, pUnboxed, nil => mUnboxed
  | vLoc l, pStringShape, nil => mStringShape {s : String} (Telescope.Get m l (bvString s))
  | vLoc l, pArrayShape, nil => mArrayShape {xs : Array Value} (Telescope.Get m l (bvArray xs))
  | vLoc l, pSexpShape, nil => mSexpShape {lb : Label} {xs : Array Value} (Telescope.Get m l (bvSexp lb xs))
  | vLoc l, pFunShape, nil => mFunShape {e : Expr} {xs : Array Var} {cl : Scope} (Telescope.Get m l (bvFun e xs cl))
  \where {

    \use \level levelProp {m : Memory} {x : Value} {pat : Pattern} {sc : Scope.Scope'} (p q : Match m x pat sc)
      : p = q \elim x, pat, sc, p, q
      | _, pWildcard, nil, mWildcard, mWildcard => idp
      | x, pNamed v pat, sc, mNamed {sc1} p1 p2, mNamed {sc2} q1 q2 =>
        \have p : sc1 = sc2 => ++-inj-left $ inv p2 *> q2
        \in Jl (\lam sc' q => \Pi (a : _) (b : _) -> mNamed p1 p2 = mNamed {_} {_} {_} {_} {_} {sc'} a b)
            (\lam a b => pmap2 mNamed (levelProp p1 a) (propPath {sc = sc1 ++ (v, x) :: nil})) p q1 q2

      | vLoc l, pArray {n} ps, sc, mArray {xs1} {scs1} g1 d1 p1, mArray {xs2} {scs2} g2 d2 p2 =>
        \have | p => Telescope.Get.functionality g1 g2
              | p' => path $ \case p __ \return Array Value \with { | bvArray xs => xs | _ => nil }
              | p'' : xs1 = {Array Value n} xs2 => =-n xs1 xs2 p'
              | q (j : Fin n) : scs1 j = scs2 j =>
                \have | d1j : Match m (xs1 j) (ps j) (scs1 j) => d1 j
                      | d1j' : Match m (xs2 j) (ps j) (scs1 j) =>
                        transport (\lam (xs : Array Value n) => Match m (xs j) (ps j) (scs1 j)) p'' d1j
                \in functionality d1j' (d2 j)
              | q' : scs1 = {Array Scope.Scope' n} scs2 => exts q
              | z => Jl (\lam (xs : Array Value n) p3
              => \Pi (a : _) (b : _) (c : DArray (\lam i => Match m (xs i) (ps i) (scs1 i)))
                  -> mArray g1 d1 p1 = {Match m (vLoc l) (pArray {n} ps) sc} mArray {_} {_} {n} {_} {_} {xs} {scs1} a c b)
                  (\lam a b c =>
                      \have | d1=c (j : Fin n) : d1 j = {Match m (xs1 j) (ps j) (scs1 j)} c j => levelProp _ _
                            | d1=c' : d1 = {DArray {n} (\lam i => Match m (xs1 i) (ps i) (scs1 i))} c => exts d1=c
                      \in path $ \lam i => mArray (propPath i) (d1=c' i)
                          (propPath { sc = {Scope.Scope'} fold (\lam sc acc => acc ++ sc) nil scs1} i))
                  p'' g2
        \in Jl (\lam (scs : Array Scope.Scope' n) p3
        => \Pi (b : _) (c : DArray (\lam i => Match m (xs2 i) (ps i) (scs i)))
        -> mArray g1 d1 p1 = mArray {_} {_} {n} {_} {_} {xs2} {scs} g2 c b) z q' p2 d2

      | vLoc l, pSexp lb {n} ps, sc, mSexp {xs1} {scs1} g1 d1 p1, mSexp {xs2} {scs2} g2 d2 p2 =>
        \have | p => Telescope.Get.functionality g1 g2
              | p' => path $ \case p __ \return Array Value \with { | bvSexp _ xs => xs | _ => nil }
              | p'' : xs1 = {Array Value n} xs2 => =-n xs1 xs2 p'
              | q (j : Fin n) : scs1 j = scs2 j =>
                \have | d1j : Match m (xs1 j) (ps j) (scs1 j) => d1 j
                      | d1j' : Match m (xs2 j) (ps j) (scs1 j) =>
                        transport (\lam (xs : Array Value n) => Match m (xs j) (ps j) (scs1 j)) p'' d1j
                \in functionality d1j' (d2 j)
              | q' : scs1 = {Array Scope.Scope' n} scs2 => exts q
              | z => Jl (\lam (xs : Array Value n) p3
              => \Pi (a : _) (b : _) (c : DArray (\lam i => Match m (xs i) (ps i) (scs1 i)))
                  -> mSexp g1 d1 p1 = {Match m (vLoc l) (pSexp lb {n} ps) sc} mSexp {_} {_} {_} {n} {_} {_} {xs} {scs1} a c b)
                  (\lam a b c =>
                      \have | d1=c (j : Fin n) : d1 j = {Match m (xs1 j) (ps j) (scs1 j)} c j => levelProp _ _
                            | d1=c' : d1 = {DArray {n} (\lam i => Match m (xs1 i) (ps i) (scs1 i))} c => exts d1=c
                      \in path $ \lam i => mSexp (propPath i) (d1=c' i)
                          (propPath { sc = {Scope.Scope'} fold (\lam sc acc => acc ++ sc) nil scs1} i))
                  p'' g2
        \in Jl (\lam (scs : Array Scope.Scope' n) p3
        => \Pi (b : _) (c : DArray (\lam i => Match m (xs2 i) (ps i) (scs i)))
            -> mSexp g1 d1 p1 = mSexp {_} {_} {_} {n} {_} {_} {xs2} {scs} g2 c b) z q' p2 d2

      | vInt x, pInt y, nil, mInt p1, mInt p2 => pmap mInt propPath
      | vLoc l, pString s, nil, mString g, mString g1 => pmap mString propPath
      | vLoc l, pBoxed, nil, mBoxed, mBoxed => idp
      | vInt i, pUnboxed, nil, mUnboxed, mUnboxed => idp
      | vLoc l, pStringShape, nil, mStringShape {s1} g1, mStringShape {s2} g2 =>
        \have | p => Telescope.Get.functionality g1 g2
              | p' => path $ \case p __ \return String \with { | bvString xs => xs | _ => nil }
        \in Jl (\lam xs q => \Pi (a : _) -> mStringShape g1 = mStringShape {_} {_} {xs} a)
            (\lam a => pmap mStringShape propPath) p' g2

      | vLoc l, pArrayShape, nil, mArrayShape {xs1} g1, mArrayShape {xs2} g2 =>
        \have | p => Telescope.Get.functionality g1 g2
              | p' => path $ \case p __ \return Array Value \with { | bvArray xs => xs | _ => nil }
        \in Jl (\lam xs q => \Pi (a : _) -> mArrayShape g1 = mArrayShape {_} {_} {xs} a)
            (\lam a => pmap mArrayShape propPath) p' g2

      | vLoc l, pSexpShape, nil, mSexpShape {lb1} {xs1} g1, mSexpShape {lb2} {xs2} g2 =>
        \have | p => Telescope.Get.functionality g1 g2
              | p' => path $ \case p __ \return \Sigma Label (Array Value)
                             \with { | bvSexp lb xs => (lb, xs) | _ => (0, nil) }
        \in Jl (\lam (lb, xs) q => \Pi (a : _) -> mSexpShape g1 = mSexpShape {_} {_} {lb} {xs} a)
            (\lam a => pmap mSexpShape propPath) p' g2

      | vLoc l, pFunShape, nil, mFunShape {e1} {xs1} {cl1} g1, mFunShape {e2} {xs2} {cl2} g2 =>
        \have | p => Telescope.Get.functionality g1 g2
              | p' => path $ \case p __ \return \Sigma Expr (Array Var) Scope
                             \with { | bvFun e xs cl => (e, xs, cl) | _ => (eSkip, nil, in~ nil) }
        \in Jl (\lam (e, xs, cl) q => \Pi (a : _) -> mFunShape g1 = mFunShape {_} {_} {e} {xs} {cl} a)
            (\lam a => pmap mFunShape propPath) p' g2

    \lemma functionality {m : Memory} {x : Value} {pat : Pattern} {sc sc' : Scope.Scope'}
                         (p : Match m x pat sc) (q : Match m x pat sc') : sc = sc' \elim x, pat, sc, p
      | x, pWildcard, nil, mWildcard =>
        \case sc' \as sc', q : Match m x pWildcard sc' \return nil = sc' \with {
          | nil, mWildcard => idp
        }

      | x, pNamed v pat, sc, mNamed {sc1} p1 p2 =>
        \case q : Match m x (pNamed v pat) sc' \return sc = sc' \with {
          | mNamed {sc2} q1 q2 =>
            \have | p => functionality p1 q1
                  | q : sc1 ++ (v, x) :: nil = sc2 ++ (v, x) :: nil => path $ \lam i => (p @ i) ++ (v, x) :: nil
            \in p2 *> q *> inv q2
        }

      | vLoc l, pArray {n} ps, sc, mArray {xs1} {scs1} g1 d1 p1 =>
        \case q : Match m (vLoc l) (pArray ps) sc' \return sc = sc' \with {
          | mArray {xs2} {scs2} g2 d2 p2 =>
            \have | p => Telescope.Get.functionality g1 g2
                  | p' => path $ \case p __ \return Array Value \with { | bvArray xs => xs | _ => nil }
                  | p'' : xs1 = {Array Value n} xs2 => =-n xs1 xs2 p'
                  | q (j : Fin n) : scs1 j = scs2 j =>
                    \have | d1j : Match m (xs1 j) (ps j) (scs1 j) => d1 j
                          | d1j' : Match m (xs2 j) (ps j) (scs1 j) =>
                            transport (\lam (xs : Array Value n) => Match m (xs j) (ps j) (scs1 j)) p'' d1j
                    \in functionality d1j' (d2 j)
                  | q' : scs1 = scs2 => ext (idp, ext q)
            \in rewriteF q' p1 *> inv p2
        }

      | vLoc l, pSexp lb {n} ps, sc, mSexp {xs1} {scs1} g1 d1 p1 =>
        \case q : Match m (vLoc l) (pSexp lb ps) sc' \return sc = sc' \with {
          | mSexp {xs2} {scs2} g2 d2 p2 =>
            \have | p => Telescope.Get.functionality g1 g2
                  | p' => path $ \case p __ \return Array Value \with { | bvSexp _ xs => xs | _ => nil }
                  | p'' : xs1 = {Array Value n} xs2 => =-n xs1 xs2 p'
                  | q (j : Fin n) : scs1 j = scs2 j =>
                    \have | d1j : Match m (xs1 j) (ps j) (scs1 j) => d1 j
                          | d1j' : Match m (xs2 j) (ps j) (scs1 j) =>
                            transport (\lam (xs : Array Value n) => Match m (xs j) (ps j) (scs1 j)) p'' d1j
                    \in functionality d1j' (d2 j)
                  | q' : scs1 = scs2 => ext (idp, ext q)
            \in rewriteF q' p1 *> inv p2
        }

      | vInt x, pInt y, nil, mInt p =>
        \case sc' \as sc', q : Match m (vInt x) (pInt y) sc' \return nil = sc' \with {
          | nil, mInt q => idp
        }

      | vLoc l, pString s, nil, mString g1 =>
        \case sc' \as sc', q : Match m (vLoc l) (pString s) sc' \return nil = sc' \with {
          | nil, mString g2 => idp
        }

      | vLoc l, pBoxed, nil, mBoxed =>
        \case sc' \as sc', q : Match m (vLoc l) pBoxed sc' \return nil = sc' \with {
          | nil, mBoxed => idp
        }

      | vInt n, pUnboxed, nil, mUnboxed =>
        \case sc' \as sc', q : Match m (vInt n) pUnboxed sc' \return nil = sc' \with {
          | nil, mUnboxed => idp
        }

      | vLoc l, pStringShape, nil, mStringShape g1 =>
        \case sc' \as sc', q : Match m (vLoc l) pStringShape sc' \return nil = sc' \with {
          | nil, mStringShape g2 => idp
        }

      | vLoc l, pArrayShape, nil, mArrayShape g1 =>
        \case sc' \as sc', q : Match m (vLoc l) pArrayShape sc' \return nil = sc' \with {
          | nil, mArrayShape g2 => idp
        }

      | vLoc l, pSexpShape, nil, mSexpShape g1 =>
        \case sc' \as sc', q : Match m (vLoc l) pSexpShape sc' \return nil = sc' \with {
          | nil, mSexpShape g2 => idp
        }

      | vLoc l, pFunShape, nil, mFunShape g1 =>
        \case sc' \as sc', q : Match m (vLoc l) pFunShape sc' \return nil = sc' \with {
          | nil, mFunShape g2 => idp
        }
  }

-- (old state, closure) == expr ==> (value, new state)
\data Eval (st : State) (cl : Scope) (e : Expr) (v : Value) (st' : State) : \Set \elim st, e, v, st'
  | (sc, m), eScope ds e, x, (sc', m') => evScope {st : State} {sc1 : Scope}
                                                  (EvalDef* (Scope.init (Def.var o ds) sc, m) cl ds st)
                                                  (Eval st cl e x (Telescope.concat sc1 sc', m'))
                                                  (sc' = Telescope.erase (Def.var o ds) (Telescope.concat sc1 sc'))
  | st, eSeq e1 e2, v2, st'' => evSeq {st' : State} {v1 : Value} (Eval st cl e1 v1 st') (Eval st' cl e2 v2 st'')
  | st, eAssign e1 e2, x, (sc', m) => evAssignVar {v : Var} {st' : State} {sc : Scope}
                                                  (EvalRef st cl e1 (rVar v) st')
                                                  (Eval st' cl e2 x (sc, m))
                                                  (sc' = Telescope.set v x sc)
  | st, eAssign e1 e2, x, (sc, m') => evAssignMem {l : Loc} {i : Nat} {st' : State} {m : Memory} {bv1 bv2 : BoxedValue}
                                                  (EvalRef st cl e1 (rElem l i) st')
                                                  (Eval st' cl e2 x (sc, m))
                                                  (Telescope.Get m l bv1) (BoxedValue.Set i x bv1 bv2)
                                                  (m' = Telescope.set l bv2 m)
  | st, eBinop b e1 e2, vInt x, st'' => evBinop {st' : State} {v1 v2 : Int}
                                                (Eval st cl e1 (vInt v1) st') (Eval st' cl e2 (vInt v2) st'')
                                                (EvalBinop b v1 v2 x)
  | st, eCall f {n} xs, x, st'' => evCall {l : Loc} {f' : Expr} {st' : State} {xs' : Array Value n}
                                          {vs : Array Var n} {sc cl' : Scope} {m : Memory}
                                          (Eval st cl f (vLoc l) st') (Eval* st' cl xs xs' (sc, m))
                                          (Telescope.Get m l (bvFun f' vs cl')) (Eval (Scope.args vs xs', m) cl' f' x st'')
  | st, eSubscript e1 e2, x, (sc, m) => evSubscript {l : Loc} {st' : State} {i : Nat} {bv : BoxedValue}
                                                    (Eval st cl e1 (vLoc l) st') (Eval st' cl e2 (vInt i) (sc, m))
                                                    (Telescope.Get m l bv) (BoxedValue.Get i x bv)
  | (sc, m), eVar v, x, st' => evVarScope (st' = (sc, m)) (Telescope.Get sc v x)
  | (sc, m), eVar v, x, st' => evVarClosure (st' = (sc, m)) (Not (\Pi (x : Value) -> Telescope.Get sc v x))
                                            (Telescope.Get cl v x)
  | st, eInt n, vInt n', st' => evInt (st = st') (n = n')
  | (sc, m), eString s, vLoc l, (sc', m') => evString (sc = sc') (m' = Telescope.set l (bvString s) m)
                                                      (Not (\Pi (x : BoxedValue) -> Telescope.Get m l x))
  | (sc, m), eFun vs e, vLoc l, (sc', m') => evFun (sc = sc') (m' = Telescope.set l (bvFun e vs (Telescope.concat sc cl)) m)
                                                   (Not (\Pi (x : BoxedValue) -> Telescope.Get m l x))
  | st, eSkip, vInt 0, st' => evSkip (st = st')
  | st, eArray {n} xs, vLoc l, (sc, m') => evArray {xs' : Array Value n} {m : Memory}
                                                   (Eval* st cl xs xs' (sc, m)) (m' = Telescope.set l (bvArray xs') m)
                                                   (Not (\Pi (x : BoxedValue) -> Telescope.Get m l x))
  | st, eSexp lb {n} xs, vLoc l, (sc, m') => evSexp {xs' : Array Value n} {m : Memory}
                                                    (Eval* st cl xs xs' (sc, m)) (m' = Telescope.set l (bvSexp lb xs') m)
                                                    (Not (\Pi (x : BoxedValue) -> Telescope.Get m l x))
  | st, eIf c t _, x, st'' => evIfTrue {c' : Int} {st' : State} (Eval st cl c (vInt c') st')
                                       (c' /= 0) (Eval st' cl t x st'')
  | st, eIf c _ f, x, st'' => evIfFalse {st' : State} (Eval st cl c (vInt 0) st') (Eval st' cl f x st'')
  | st, eWhile c b, x, st'' => evWhileTrue {c' : Int} {st' : State} (Eval st cl c (vInt c') st')
                                           (c' /= 0) (Eval st' cl (eWhile c b) x st'')
  | st, eWhile c _, vInt 0, st' => evWhileFalse (Eval st cl c (vInt 0) st')
  | st, eDo b c, x, st''' => evDoTrue {x' : Value} {c' : Int} {st' st'' : State} (Eval st cl b x' st')
                                      (Eval st' cl c (vInt c') st'') (c' /= 0) (Eval st'' cl (eDo b c) x st''')
  | st, eDo b c, vInt 0, st'' => evDoFalse {x' : Value} {st' : State} (Eval st cl b x' st')
                                           (Eval st' cl c (vInt 0) st'')
  | st, eCase e {n} pbs, x, st'' => evCase {x' : Value} {st' : State} (Eval st cl e x' st')
                                           (EvalCase st' cl x' pbs x st'')

-- multiple expressions evaluation left to right
\data Eval* (st : State) (cl : Scope) {n : Nat} (es : Array Expr n) (xs : Array Value n) (st' : State) : \Set
\elim st, n, es, xs, st'
  | st, 0, nil, nil, st' => ev*Nil (st = st')
  | st, suc _, e :: es, x :: xs, st'' => ev*Cons {st' : State} (Eval st cl e x st') (Eval* st' cl es xs st'')

\data EvalRef (st : State) (cl : Scope) (e : Expr) (r : Ref) (st' : State) : \Set \elim st, e, r, st'
  | st, eVar v, rVar v', st' => erVar (st = st') (v = v')
  | st, eSubscript t1 t2, rElem l i, st'' => erSubscript {st' : State} (Eval st cl t1 (vLoc l) st')
                                                         (Eval st' cl t2 (vInt i) st'')

\data EvalDef (st : State) (cl : Scope) (d : Def) (st' : State) : \Set \elim st, d, st'
  | st, dVar v e, (sc', m) => edVar {x : Value} {sc : Scope} (Eval st cl e x (sc, m)) (sc' = Telescope.set v x sc)
  | (sc, m), dFun v vs e, (sc', m') => edFun {l : Loc} (m' = Telescope.set l (bvFun e vs (Telescope.concat sc cl)) m)
                                             (sc' = Telescope.set v (vLoc l) sc)

\data EvalDef* (st : State) (cl : Scope) {n : Nat} (ds : Array Def n) (st' : State) : \Set \elim st, n, ds, st'
  | st, 0, nil, st' => ed*Nil (st = st')
  | st, suc _, d :: ds, st'' => ed*Cons {st' : State} (EvalDef st cl d st') (EvalDef* st' cl ds st'')

\data EvalCase (st : State) (cl : Scope) (x : Value) {n : Nat} (pbs : Array (\Sigma Pattern Expr) n)
               (y : Value) (st' : State) : \Set \elim st, n, pbs, st'
  | (sc, m), suc _, (p, e) :: pbs, (sc', m') => ecHead {sc1 : Scope.Scope'} {sc2 : Scope} (Match m x p sc1)
                                                       (Eval (Telescope.concat (in~ sc1) sc, m) cl e y (Telescope.concat sc2 sc', m'))
                                                       (sc' = Telescope.erase ((\lam p => p.1) o sc1) (Telescope.concat sc2 sc'))
  | (sc, m), suc _, (p, _) :: pbs, st' => ecTail (\Pi (sc : Scope.Scope') -> Not (Match m x p sc))
                                                 (EvalCase (sc, m) cl x pbs y st')
